function newstatOB(set, BOOT)
%NEWSTATOB Three things that are, ugh . . .
% 1. Spearman correlation
% 2. Bootstrap slices for fit slope; check how often the slope changes
%   signs
% 3. Shuffle slices to calculate pvalue wrt shuffling
%#ok<*UNRCH>
USE_NORMALPDF = true;
CROSSVAL = 10;
pval_est = @(t, n) 2 * min(tcdf(t.*sqrt((n-2)./(1-t.^2)), n), tcdf(t.*sqrt((n-2)./(1-t.^2)), n, 'upper'));
PMIN = 1/BOOT;
% Collapse the regions into one; use only mitral cell data
regmat = [ ...
  sum(set.prjImg(:, set.prjRegInd{1}), 2), ...
  sum(set.prjImg(:, set.prjRegInd{4}), 2), ...
  sum(set.prjImg(:, set.prjRegInd{5}), 2), ...
  sum(set.prjImg(:, set.prjRegInd{6}), 2)];
apcmat = set.prjImg(:, set.prjRegInd{2});
ppcmat = set.prjImg(:, set.prjRegInd{3});
pcmat = [apcmat, ppcmat];
% Useful
n_brc = size(regmat, 1);
n_reg = size(regmat, 2);
n_apc = size(apcmat, 2);
n_ppc = size(ppcmat, 2);
n_sli = size(pcmat, 2);
% Barcode shuffling stuff
rng('default');
bar_boot = ceil(n_brc * rand(n_brc, BOOT));
% Seed RNG
rng('default');

% Store variables here
outstr = struct();

% Limits for fitting
l_spl = [1 - 1e-5; n_apc + .5; n_sli];
l_lin = [1 - 1e-5; n_sli];
l_apc = [1 - 1e-5; n_apc];
l_ppc = [1 - 1e-5; n_ppc];

% Calculate the full OB matrix
outstr.conProb_pc = aux.conProb(regmat, pcmat);
outstr.conProb_apc = outstr.conProb_pc(:, 1:n_apc);
outstr.conProb_ppc = outstr.conProb_pc(:, n_apc + (1:n_ppc));

% Calculate statistics on these quantities using bootstrap
this_mat = zeros([size(outstr.conProb_pc), BOOT]);
for b = 1:BOOT
  this_mat(:, :, b) = aux.conProb( ...
    regmat(bar_boot(:, b), :), ...
    pcmat(bar_boot(:, b), :));
end
outstr.conProb_pc_sdev = std(this_mat, 0, 3);
outstr.conProb_pc_mean = mean(this_mat, 3);

% 1. Calculate spearman correlation between regions and PC
[outstr.conProb_pc_sprCorr, outstr.conProb_pc_sprCorrPval] = ...
  corr(outstr.conProb_pc', (1:n_sli)', 'Type', 'Spearman');
[outstr.conProb_apc_sprCorr, outstr.conProb_apc_sprCorrPval] = ...
  corr(outstr.conProb_apc', (1:n_apc)', 'Type', 'Spearman');
[outstr.conProb_ppc_sprCorr, outstr.conProb_ppc_sprCorrPval] = ...
  corr(outstr.conProb_ppc', (1:n_ppc)', 'Type', 'Spearman');
outstr.conProb_pc_sprCorrPval2 = pval_est(outstr.conProb_pc_sprCorr, 24);
outstr.conProb_apc_sprCorrPval2 = pval_est(outstr.conProb_apc_sprCorr, 12);
outstr.conProb_ppc_sprCorrPval2 = pval_est(outstr.conProb_ppc_sprCorr, 12);

% 2. Fit several lines using bootstrap
s_bootApc = ceil(n_apc * rand(BOOT, n_apc));
s_bootPpc = ceil(n_ppc * rand(BOOT, n_ppc));
s_bootPc = [s_bootApc, n_apc + s_bootPpc];
cpFit_b_spl = zeros(3, n_reg, BOOT);
cpFit_b_lin = zeros(2, n_reg, BOOT);
cpFit_b_apc = zeros(2, n_reg, BOOT);
cpFit_b_ppc = zeros(2, n_reg, BOOT);
cpFit_m_spl = zeros(2, n_reg, BOOT);
cpFit_m_lin = zeros(1, n_reg, BOOT);
cpFit_m_apc = zeros(1, n_reg, BOOT);
cpFit_m_ppc = zeros(1, n_reg, BOOT);
for r = 1:n_reg
  for i = 1:BOOT
    [cpFit_m_spl(:, r, i), cpFit_b_spl(:, r, i)] = aux.splineFit( ...
      s_bootPc(i, :), outstr.conProb_pc(r, s_bootPc(i, :)), l_spl);
    [cpFit_m_lin(:, r, i), cpFit_b_lin(:, r, i)] = aux.splineFit( ...
      s_bootPc(i, :), outstr.conProb_pc(r, s_bootPc(i, :)), l_lin);
    [cpFit_m_apc(:, r, i), cpFit_b_apc(:, r, i)] = aux.splineFit( ...
      s_bootApc(i, :), outstr.conProb_apc(r, s_bootApc(i, :)), l_apc);
    [cpFit_m_ppc(:, r, i), cpFit_b_ppc(:, r, i)] = aux.splineFit( ...
      s_bootPpc(i, :), outstr.conProb_ppc(r, s_bootPpc(i, :)), l_ppc);
  end
end
outstr.cpFit_b_spline = mean(cpFit_b_spl, 3);
outstr.cpFit_m_spline = mean(cpFit_m_spl, 3);
outstr.cpFit_b_linear = mean(cpFit_b_lin, 3);
outstr.cpFit_m_linear = mean(cpFit_m_lin, 3);
outstr.cpFit_b_apc = mean(cpFit_b_apc, 3);
outstr.cpFit_m_apc = mean(cpFit_m_apc, 3);
outstr.cpFit_b_ppc = mean(cpFit_b_ppc, 3);
outstr.cpFit_m_ppc = mean(cpFit_m_ppc, 3);

outstr.cpFit_b_spline_std = std(cpFit_b_spl, 0, 3);
outstr.cpFit_m_spline_std = std(cpFit_m_spl, 0, 3);
outstr.cpFit_b_linear_std = std(cpFit_b_lin, 0, 3);
outstr.cpFit_m_linear_std = std(cpFit_m_lin, 0, 3);
outstr.cpFit_b_apc_std = std(cpFit_b_apc, 0, 3);
outstr.cpFit_m_apc_std = std(cpFit_m_apc, 0, 3);
outstr.cpFit_b_ppc_std = std(cpFit_b_ppc, 0, 3);
outstr.cpFit_m_ppc_std = std(cpFit_m_ppc, 0, 3);

outstr.cpFit_b_spline_pval = zeros(3, n_reg, 2);
outstr.cpFit_m_spline_pval = zeros(2, n_reg, 2);
outstr.cpFit_b_linear_pval = zeros(2, n_reg, 2);
outstr.cpFit_m_linear_pval = zeros(1, n_reg, 2);
outstr.cpFit_b_apc_pval = zeros(2, n_reg, 2);
outstr.cpFit_m_apc_pval = zeros(1, n_reg, 2);
outstr.cpFit_b_ppc_pval = zeros(2, n_reg, 2);
outstr.cpFit_m_ppc_pval = zeros(1, n_reg, 2);

if USE_NORMALPDF
  thisCalc = @(dat) 1 - erf(abs(mean(dat, 3)) ./ std(dat, 0, 3) ./ sqrt(2));
  outstr.cpFit_b_spline_pval(:, :, 1) = thisCalc(cpFit_b_spl);
  outstr.cpFit_m_spline_pval(:, :, 1) = thisCalc(cpFit_m_spl);
  outstr.cpFit_b_linear_pval(:, :, 1) = thisCalc(cpFit_b_lin);
  outstr.cpFit_m_linear_pval(:, :, 1) = thisCalc(cpFit_m_lin);
  outstr.cpFit_b_apc_pval(:, :, 1) = thisCalc(cpFit_b_apc);
  outstr.cpFit_m_apc_pval(:, :, 1) = thisCalc(cpFit_m_apc);
  outstr.cpFit_b_ppc_pval(:, :, 1) = thisCalc(cpFit_b_ppc);
  outstr.cpFit_m_ppc_pval(:, :, 1) = thisCalc(cpFit_m_ppc);
else
  thisCalc = @(dat) 2 * min(mean(dat > 0, 3), mean(dat < 0, 3));
  outstr.cpFit_b_spline_pval(:, :, 1) = thisCalc(cpFit_b_spl);
  outstr.cpFit_m_spline_pval(:, :, 1) = thisCalc(cpFit_m_spl);
  outstr.cpFit_b_linear_pval(:, :, 1) = thisCalc(cpFit_b_lin);
  outstr.cpFit_m_linear_pval(:, :, 1) = thisCalc(cpFit_m_lin);
  outstr.cpFit_b_apc_pval(:, :, 1) = thisCalc(cpFit_b_apc);
  outstr.cpFit_m_apc_pval(:, :, 1) = thisCalc(cpFit_m_apc);
  outstr.cpFit_b_ppc_pval(:, :, 1) = thisCalc(cpFit_b_ppc);
  outstr.cpFit_m_ppc_pval(:, :, 1) = thisCalc(cpFit_m_ppc);
end

% 3. Shuffling slices; then check percentage of what is
% different
cpFitS_b_spl = zeros(3, n_reg, BOOT);
cpFitS_b_lin = zeros(2, n_reg, BOOT);
cpFitS_b_apc = zeros(2, n_reg, BOOT);
cpFitS_b_ppc = zeros(2, n_reg, BOOT);
cpFitS_m_spl = zeros(2, n_reg, BOOT);
cpFitS_m_lin = zeros(1, n_reg, BOOT);
cpFitS_m_apc = zeros(1, n_reg, BOOT);
cpFitS_m_ppc = zeros(1, n_reg, BOOT);
for r = 1:n_reg
  for i = 1:BOOT
    s_shufApc = randperm(n_apc);
    s_shufPpc = randperm(n_ppc);
    s_shufPc = randperm(n_apc + n_ppc);
    % For splines fit and linear; mix APC and PPC
    [cpFitS_m_spl(:, r, i), cpFitS_b_spl(:, r, i)] = aux.splineFit( ...
      s_bootPc(i, s_shufPc), outstr.conProb_pc(r, s_bootPc(i, :)), l_spl);
    [cpFitS_m_lin(:, r, i), cpFitS_b_lin(:, r, i)] = aux.splineFit( ...
      s_bootPc(i, s_shufPc), outstr.conProb_pc(r, s_bootPc(i, :)), l_lin);
    % For seperate linear fits; don't mix APC and PPC
    [cpFitS_m_apc(:, r, i), cpFitS_b_apc(:, r, i)] = aux.splineFit( ...
      s_bootApc(i, s_shufApc), outstr.conProb_apc(r, s_bootApc(i, :)), l_apc);
    [cpFitS_m_ppc(:, r, i), cpFitS_b_ppc(:, r, i)] = aux.splineFit( ...
      s_bootPpc(i, s_shufPpc), outstr.conProb_ppc(r, s_bootPpc(i, :)), l_ppc);
  end
end
if USE_NORMALPDF
  thisCalc = @(nh, dat) 1 - erf(abs(mean((dat - nh), 3) ./ ...
    std(dat, 0, 3) ./ sqrt(2)));
  outstr.cpFit_b_spline_pval(:, :, 2) = thisCalc(outstr.cpFit_b_spline, cpFitS_b_spl);
  outstr.cpFit_m_spline_pval(:, :, 2) = thisCalc(outstr.cpFit_m_spline, cpFitS_m_spl);
  outstr.cpFit_b_linear_pval(:, :, 2) = thisCalc(outstr.cpFit_b_linear, cpFitS_b_lin);
  outstr.cpFit_m_linear_pval(:, :, 2) = thisCalc(outstr.cpFit_m_linear, cpFitS_m_lin);
  outstr.cpFit_b_apc_pval(:, :, 2) = thisCalc(outstr.cpFit_b_apc, cpFitS_b_apc);
  outstr.cpFit_m_apc_pval(:, :, 2) = thisCalc(outstr.cpFit_m_apc, cpFitS_m_apc);
  outstr.cpFit_b_ppc_pval(:, :, 2) = thisCalc(outstr.cpFit_b_ppc, cpFitS_b_ppc);
  outstr.cpFit_m_ppc_pval(:, :, 2) = thisCalc(outstr.cpFit_m_ppc, cpFitS_m_ppc);
else
  thisCalc = @(nh, dat) 2 * min( ...
    mean((dat - nh) > 0, 3), ...
    mean((dat - nh) < 0, 3));
  outstr.cpFit_b_spline_pval(:, :, 2) = thisCalc(outstr.cpFitS_b_spline, cpFitS_b_spl);
  outstr.cpFit_m_spline_pval(:, :, 2) = thisCalc(outstr.cpFit_m_spline, cpFitS_m_spl);
  outstr.cpFit_b_linear_pval(:, :, 2) = thisCalc(outstr.cpFit_b_linear, cpFitS_b_lin);
  outstr.cpFit_m_linear_pval(:, :, 2) = thisCalc(outstr.cpFit_m_linear, cpFitS_m_lin);
  outstr.cpFit_b_apc_pval(:, :, 2) = thisCalc(outstr.cpFit_b_apc, cpFitS_b_apc);
  outstr.cpFit_m_apc_pval(:, :, 2) = thisCalc(outstr.cpFit_m_apc, cpFitS_m_apc);
  outstr.cpFit_b_ppc_pval(:, :, 2) = thisCalc(outstr.cpFit_b_ppc, cpFitS_b_ppc);
  outstr.cpFit_m_ppc_pval(:, :, 2) = thisCalc(outstr.cpFit_m_ppc, cpFitS_m_ppc);
end

% Fix p-values to lower limits
outstr.cpFit_b_linear_pval(outstr.cpFit_b_linear_pval(:) < PMIN) = PMIN;
outstr.cpFit_b_spline_pval(outstr.cpFit_b_spline_pval(:) < PMIN) = PMIN;
outstr.cpFit_b_apc_pval(outstr.cpFit_b_apc_pval(:) < PMIN) = PMIN;
outstr.cpFit_b_ppc_pval(outstr.cpFit_b_ppc_pval(:) < PMIN) = PMIN;
outstr.cpFit_m_linear_pval(outstr.cpFit_m_linear_pval(:) < PMIN) = PMIN;
outstr.cpFit_m_spline_pval(outstr.cpFit_m_spline_pval(:) < PMIN) = PMIN;
outstr.cpFit_m_apc_pval(outstr.cpFit_m_apc_pval(:) < PMIN) = PMIN;
outstr.cpFit_m_ppc_pval(outstr.cpFit_m_ppc_pval(:) < PMIN) = PMIN;

% Get goodness of fit using K-fold cross validation
cpFit_linear_r2 = zeros(BOOT, CROSSVAL, n_reg);
cpFit_spline_r2 = zeros(BOOT, CROSSVAL, n_reg);
cpFit_region_r2 = zeros(BOOT, CROSSVAL, n_reg);
sto_matVald = zeros(n_reg, n_sli, CROSSVAL);
sto_matTest = zeros(n_reg, n_sli, CROSSVAL);
sto_matPredLin = zeros(n_reg, n_sli, CROSSVAL);
sto_matPredSpl = zeros(n_reg, n_sli, CROSSVAL);
sto_matPredReg = zeros(n_reg, n_sli, CROSSVAL);
cpFit_b_spl = zeros(3, n_reg, CROSSVAL);
cpFit_b_lin = zeros(2, n_reg, CROSSVAL);
cpFit_b_apc = zeros(2, n_reg, CROSSVAL);
cpFit_b_ppc = zeros(2, n_reg, CROSSVAL);
cpFit_m_spl = zeros(2, n_reg, CROSSVAL);
cpFit_m_lin = zeros(1, n_reg, CROSSVAL);
cpFit_m_apc = zeros(1, n_reg, CROSSVAL);
cpFit_m_ppc = zeros(1, n_reg, CROSSVAL);
outstr.cpFit_boot_linR2 = zeros(BOOT, n_reg);
outstr.cpFit_boot_splR2 = zeros(BOOT, n_reg);
outstr.cpFit_boot_regR2 = zeros(BOOT, n_reg);
for b = 1:BOOT
  % Get crossvalidation indices
  sto_i = crossvalind('Kfold', n_brc, CROSSVAL);
  % Get the validation and testing set for each cross validation set
  for k = 1:CROSSVAL
    s_i = (sto_i == k);
    sto_matVald(:, :, k) = aux.conProb(regmat( s_i, :), pcmat( s_i, :));
    sto_matTest(:, :, k) = aux.conProb(regmat(~s_i, :), pcmat(~s_i, :));
  end
  % Run fits on the test sets for each dataset and each region
  for k = 1:CROSSVAL
    for r = 1:n_reg
      [cpFit_m_lin(:, r, k), cpFit_b_lin(:, r, k)] = aux.splineFit( ...
        1:n_sli, sto_matTest(r,:, k), l_spl([1, 3]));
      [cpFit_m_spl(:, r, k), cpFit_b_spl(:, r, k)] = aux.splineFit( ...
        1:n_sli, sto_matTest(r,:, k), l_spl(1:3));
      [cpFit_m_apc(:, r, k), cpFit_b_apc(:, r, k)] = aux.splineFit( ...
        1:n_apc, sto_matTest(r,1:n_apc, k), l_spl(1:2));
      [cpFit_m_ppc(:, r, k), cpFit_b_ppc(:, r, k)] = aux.splineFit( ...
        (1:n_ppc) + n_apc, sto_matTest(r,(1:n_ppc) + n_apc, k), l_spl(2:3));
      % Find m and b for fits
      sto_linmb = [l_spl(1), 1; l_spl(3), 1] \ [cpFit_b_lin(1, r, k); cpFit_b_lin(2, r, k)];
      sto_spl_a = [l_spl(1), 1; l_spl(2), 1] \ [cpFit_b_spl(1, r, k); cpFit_b_spl(2, r, k)];
      sto_spl_p = [l_spl(2), 1; l_spl(3), 1] \ [cpFit_b_spl(2, r, k); cpFit_b_spl(3, r, k)];
      sto_reg_a = [l_spl(1), 1; l_spl(2), 1] \ [cpFit_b_apc(1, r, k); cpFit_b_apc(2, r, k)];
      sto_reg_p = [l_spl(2), 1; l_spl(3), 1] \ [cpFit_b_ppc(1, r, k); cpFit_b_ppc(2, r, k)];
      % Using the m and b values; predict the matrix values
      sto_matPredLin(r, :, k) = (sto_linmb(1) * (1:n_sli)) + sto_linmb(2);
      sto_matPredSpl(r, 1:n_apc, k) = ...
        (sto_spl_a(1) * (1:n_apc)) + sto_spl_a(2);
      sto_matPredSpl(r, n_apc + (1:n_ppc), k) = ...
        (sto_spl_p(1) * (n_apc + (1:n_ppc))) + sto_spl_p(2);
      sto_matPredReg(r, 1:n_apc, k) = ...
        (sto_reg_a(1) * (1:n_apc)) + sto_reg_a(2);
      sto_matPredReg(r, n_apc + (1:n_ppc), k) = ...
        (sto_reg_p(1) * (n_apc + (1:n_ppc))) + sto_reg_p(2);
      % Calculate the R2 value on the validation set
      cpFit_linear_r2(b, k, r) = sum( ...
        (sto_matPredLin(r, :, k) - sto_matVald(r, :, k)) .^ 2);
      cpFit_spline_r2(b, k, r) = sum( ...
        (sto_matPredSpl(r, :, k) - sto_matVald(r, :, k)) .^ 2);
      cpFit_region_r2(b, k, r) = sum( ...
        (sto_matPredReg(r, :, k) - sto_matVald(r, :, k)) .^ 2);
    end
  end
  % Record the R2 values for each fit
  for r = 1:n_reg
    outstr.cpFit_boot_linR2(b, r) = sum(cpFit_linear_r2(b, :, r), 'all');
    outstr.cpFit_boot_splR2(b, r) = sum(cpFit_spline_r2(b, :, r), 'all');
    outstr.cpFit_boot_regR2(b, r) = sum(cpFit_region_r2(b, :, r), 'all');
  end
end
% Get the average values for R2 for the fits
outstr.cpFit_linear_r2 = mean(outstr.cpFit_boot_linR2, 1)';
outstr.cpFit_spline_r2 = mean(outstr.cpFit_boot_splR2, 1)';
outstr.cpFit_region_r2 = mean(outstr.cpFit_boot_regR2, 1)';
% Get p value wrt the linear
s_s = std(outstr.cpFit_boot_linR2, 0, 1);
outstr.cpFit_spline_r2_pval = zeros(n_reg, 1);
outstr.cpFit_region_r2_pval = zeros(n_reg, 1);
for r = 1:n_reg
  [~, outstr.cpFit_spline_r2_pval(r)] = ztest( ...
    outstr.cpFit_boot_splR2(:, r), outstr.cpFit_linear_r2(r), s_s(r));
  [~, outstr.cpFit_region_r2_pval(r)] = ztest( ...
    outstr.cpFit_boot_regR2(:, r), outstr.cpFit_linear_r2(r), s_s(r));
end
outstr.cpFit_spline_r2_pval(outstr.cpFit_spline_r2_pval(:) < PMIN) = PMIN;
outstr.cpFit_region_r2_pval(outstr.cpFit_region_r2_pval(:) < PMIN) = PMIN;

% Do table for easy reading
outstr.pTable = table( ...
  outstr.conProb_pc_sprCorrPval, ...
  outstr.conProb_apc_sprCorrPval, outstr.conProb_ppc_sprCorrPval, ...
  outstr.cpFit_m_spline_pval(1, :, 1)', outstr.cpFit_m_spline_pval(2, :, 1)', ...
  outstr.cpFit_m_linear_pval(1, :, 1)', ...
  outstr.cpFit_m_apc_pval(1, :, 1)', outstr.cpFit_m_ppc_pval(1, :, 1)', ...
  outstr.cpFit_m_spline_pval(1, :, 2)', outstr.cpFit_m_spline_pval(2, :, 2)', ...
  outstr.cpFit_m_linear_pval(1, :, 2)', ...
  outstr.cpFit_m_apc_pval(1, :, 2)', outstr.cpFit_m_ppc_pval(1, :, 2)', ...
  'RowNames', set.prjRegName([1, 4, 5, 6]), 'VariableNames', { ...
  'Spearman Corr p', ...
  'Spearman Corr APC p', 'Spearman Corr PPC p', ...
  'BS: Piecewise APC p', 'BS: Piecewise PPC p', ...
  'BS: Linear p', ...
  'BS: APC p', 'BS: PPC p', ...
  'Shuf: Piecewise APC p', 'Shuf: Piecewise PPC p', ...
  'Shuf: Linear p', ...
  'Shuf: APC p', 'Shuf: PPC p'});

outstr.dTable = table( ...
  outstr.conProb_pc_sprCorr, ...
  outstr.conProb_apc_sprCorr, outstr.conProb_ppc_sprCorr, ...
  outstr.cpFit_m_spline(1, :)', outstr.cpFit_m_spline(2, :)', ...
  outstr.cpFit_m_linear', ...
  outstr.cpFit_m_apc', outstr.cpFit_m_ppc', ...
  'RowNames', set.prjRegName([1, 4, 5, 6]), 'VariableNames', { ...
  'Spearman Corr', ...
  'Spearman Corr APC', 'Spearman Corr PPC', ...
  'Piecewise fit APC slope', 'Piecewise fit PPC slope', ...
  'Linear fit slope', ...
  'APC fit slope', 'PPC fit slope'});

outstr.tTable = table( ...
  outstr.cpFit_linear_r2, ...
  outstr.cpFit_spline_r2, outstr.cpFit_spline_r2_pval, ...
  outstr.cpFit_region_r2, outstr.cpFit_region_r2_pval, ...
  'RowNames', set.prjRegName([1, 4, 5, 6]), 'VariableNames', { ...
  'Linear fit Average test r2', ...
  'Piecewise fit Average test r2', 'Piecewise fit test r2 pval'...
  'APC/PPC fit Average test r2', 'APC/PPC fit test r2 pval'});

outstr.oTable = table( ...
  outstr.conProb_pc_sprCorr, ...
  outstr.conProb_pc_sprCorrPval2, ...
  outstr.conProb_apc_sprCorr, ...
  outstr.conProb_apc_sprCorrPval2, ...
  outstr.conProb_ppc_sprCorr, ...
  outstr.conProb_ppc_sprCorrPval2, ...
  outstr.cpFit_m_linear', ...
  outstr.cpFit_m_linear_pval(1, :, 1)', ...
  outstr.cpFit_m_linear_pval(1, :, 2)', ...
  outstr.cpFit_linear_r2, ...
  outstr.cpFit_m_spline(1, :)', ...
  outstr.cpFit_m_spline_pval(1, :, 1)', ...
  outstr.cpFit_m_spline_pval(1, :, 2)', ...
  outstr.cpFit_m_spline(2, :)', ...
  outstr.cpFit_m_spline_pval(2, :, 1)', ...
  outstr.cpFit_m_spline_pval(2, :, 2)', ...
  outstr.cpFit_spline_r2, ...
  outstr.cpFit_spline_r2_pval, ...
  outstr.cpFit_m_apc', ...
  outstr.cpFit_m_apc_pval(1, :, 1)', ...
  outstr.cpFit_m_apc_pval(1, :, 2)', ...
  outstr.cpFit_m_ppc', ...
  outstr.cpFit_m_ppc_pval(1, :, 1)', ...
  outstr.cpFit_m_ppc_pval(1, :, 2)', ...
  outstr.cpFit_region_r2, ...
  outstr.cpFit_region_r2_pval, ...
  'RowNames', set.prjRegName([1, 4, 5, 6]), 'VariableNames', { ...
  'PC Spearman Correlation', ...
  'PC Spearman Corr. p-value', ...
  'APC Spearman Correlation', ...
  'APC Spearman Corr. p-value', ...
  'PPC Spearman Correlation', ...
  'PPC Spearman Corr. p-value', ...
  'PC Linear Fit Slope', ...
  'PC Linear Fit Slope p-value (bootstrap)', ...
  'PC Linear Fit Slope p-value (shuffle)', ...
  'PC Linear Fit, mean r2 error', ...
  'Piecewise Fit, APC Slope', ...
  'Piecewise Fit, APC Slope p-value (bootstrap)', ...
  'Piecewise Fit, APC Slope p-value (shuffle)', ...
  'Piecewise Fit, PPC Slope', ...
  'Piecewise Fit, PPC Slope p-value (bootstrap)', ...
  'Piecewise Fit, PPC Slope p-value (shuffle)', ...
  'Piecewise Fit, mean r2 error', ...
  'Piecewise Fit, mean r2 error p-value', ...
  'APC Linear Fit Slope', ...
  'APC Linear Fit Slope p-value (bootstrap)', ...
  'APC Linear Fit Slope p-value (shuffle)', ...
  'PPC Linear Fit Slope', ...
  'PPC Linear Fit Slope p-value (bootstrap)', ...
  'PPC Linear Fit Slope p-value (shuffle)', ...
  'AP Linear Fits, mean r2 error', ...
  'AP Linear Fits, mean r2 error p-value'});

set.data.OBPC = outstr;
rng('shuffle');

end

